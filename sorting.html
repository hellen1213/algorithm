<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>sorting</title>
<style type="text/css">
.subtitle {
	font-size: 18px;
}
.subtitle em {
	color: #FC0;
}
.subtitle {
	font-size: 16px;
	color: #FFCC00;
}
.sub {
	font-size: 16px;
	color: #FC0;
}
.sub {
	font-size: 16px;
}
.sub {
	font-size: 17px;
	color: #333;
}
.sub em {
	color: #FC0;
}
</style>
</head>

<body>
<p align="center"><strong>Sorting algorithm</strong></p>
<hr />
<p><img src="images/header.jpg" width="1580" height="179" /></p>
<p class="sub"><em>1. Bubble Sort</em></p>
<p><strong><img src="images/bubble.gif" width="300" height="180" />Bubble sort</strong>, sometimes referred to as <strong>sinking sort</strong>, is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swap them if they are in the wrong order. The pass through the list is   repeated until no swaps are needed, which indicates that the list is   sorted</p>
<p class="sub"><em>2. Selection Sort</em></p>
<p class="sub">The algorithm divides the input list into two parts: the sublist of   items already sorted, which is built up from left to right at the front   (left) of the list, and the sublist of items remaining to be sorted that   occupy the rest of the list. Initially, the sorted sublist is empty and   the unsorted sublist is the entire input list. The algorithm proceeds   by finding the smallest (or largest, depending on sorting order) element   in the unsorted sublist, exchanging it with the leftmost unsorted   element (putting it in sorted order), and moving the sublist boundaries   one element to the right.</p>
<p class="subtitle"><em>3. Merge Sort</em></p>
<p align="left"><img src="images/selection.gif" width="280" height="237" />Conceptually, a merge sort works as follows:</p>
<ol>
  <li>Divide the unsorted list into <em>n</em> sublists, each containing 1 element (a list of 1 element is considered sorted).</li>
  <li>Repeatedly merge sublists to produce new sorted sublists until there is only 1 sublist remaining. This will be the sorted list.</li>
</ol>
<p class="subtitle"><em>4. Quick Sort</em></p>
<div align="left"><img src="images/quicksort.gif" width="280" height="214" />Quicksort is a divide and conquer algorithm.   Quicksort first divides a large array into two smaller sub-arrays: the   low elements and the high elements. Quicksort can then recursively sort   the sub-arrays.
</div>
<p>The steps are:</p>
<ol>
  <li>Pick an element, called a <strong>pivot</strong>, from the array.</li>
  <li>Reorder the array so that all elements with values less than the   pivot come before the pivot, while all elements with values greater than   the pivot come after it (equal values can go either way). After this   partitioning, the pivot is in its final position. This is called the <strong>partition</strong> operation.</li>
  <li>Recursively apply the above steps to the sub-array of elements with smaller values   and separately to the sub-array of elements with greater values.</li>
</ol>
<p>The base case of the recursion is arrays of size zero or one, which never need to be sorted.</p>
<p class="sub"><em>5. Insertion Sort</em></p>
<p align="left"><img src="images/insertion.gif" width="300" height="180" />The most common variant of insertion sort, which operates on arrays, can be described as follows:</p>
<ol>
  <li>Suppose there exists a function called <em>Insert</em> designed to   insert a value into a sorted sequence at the beginning of an array. It   operates by beginning at the end of the sequence and shifting each   element one place to the right until a suitable position is found for   the new element. The function has the side effect of overwriting the   value stored immediately after the sorted sequence in the array.</li>
  <li>To perform an insertion sort, begin at the left-most element of the array and invoke <em>Insert</em> to insert each element encountered into its correct position. The   ordered sequence into which the element is inserted is stored at the   beginning of the array in the set of indices already examined. Each   insertion overwrites a single value: the value being inserted.</li>
</ol>
<p class="sub">&nbsp;</p>
<p><em><a href="https://github.com/hellen1213/sorting">(Hint and Solution)</a></em></p>
</body>
</html>
